Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.


    Report from: Interprocedural optimizations [ipo]

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000


Begin optimization report for: main(int, char **)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (main(int, char **)) [1] vectorsum.c(265,35)
  -> EXTERN: (268,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (269,5) exit(int)
  -> INLINE: (275,3) mapFileToMemory(char *__restrict__, Vector *__restrict__)
    -> INLINE (MANUAL): (85,3) stat(const char *, struct stat *)
      -> EXTERN: /usr/include/sys/stat.h:(457,10) __xstat(int, const char *, struct stat *)
    -> EXTERN: (89,8) open(const char *, int, ...)
    -> EXTERN: (91,5) perror(const char *)
    -> EXTERN: (92,5) close(int)
    -> EXTERN: (93,5) exit(int)
    -> EXTERN: (96,17) mmap(void *, size_t, int, int, int, __off_t)
    -> EXTERN: (98,5) perror(const char *)
    -> EXTERN: (99,5) close(int)
    -> EXTERN: (100,5) exit(int)
    -> EXTERN: (105,3) close(int)
  -> INLINE: (276,3) initVectorArray(Vector *, int)
    -> EXTERN: (182,31) malloc(size_t)
    -> EXTERN: (185,5) perror(const char *)
    -> EXTERN: (186,5) exit(int)
  -> INLINE: (277,3) storeVectorToArray(Vector *)
    -> INLINE: (235,9) doubleArraySize(Vector *)
      -> EXTERN: (199,31) malloc(size_t)
      -> EXTERN: (202,5) perror(const char *)
      -> EXTERN: (203,5) exit(int)
      -> EXTERN: (207,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
      -> EXTERN: (213,3) free(void *)
    -> INLINE (MANUAL): (239,36) atof(const char *)
      -> EXTERN: /usr/include/stdlib.h:(281,10) strtod(const char *__restrict__, char **__restrict__)
    -> EXTERN: (245,7) memset(void *, int, size_t)
  -> INLINE: (278,3) unmapFile(Vector *)
    -> EXTERN: (113,7) munmap(void *, size_t)
    -> EXTERN: (114,4) perror(const char *)
    -> EXTERN: (115,4) exit(int)
  -> INLINE: (279,3) computeHistogram(Vector *__restrict__, int, int)
    -> EXTERN: (39,15) malloc(size_t)
    -> EXTERN: (42,5) memset(void *, int, size_t)
  -> INLINE: (284,3) mapFileToMemory(char *__restrict__, Vector *__restrict__)
    -> INLINE (MANUAL): (85,3) stat(const char *, struct stat *)
      -> EXTERN: /usr/include/sys/stat.h:(457,10) __xstat(int, const char *, struct stat *)
    -> EXTERN: (89,8) open(const char *, int, ...)
    -> EXTERN: (91,5) perror(const char *)
    -> EXTERN: (92,5) close(int)
    -> EXTERN: (93,5) exit(int)
    -> EXTERN: (96,17) mmap(void *, size_t, int, int, int, __off_t)
    -> EXTERN: (98,5) perror(const char *)
    -> EXTERN: (99,5) close(int)
    -> EXTERN: (100,5) exit(int)
    -> EXTERN: (105,3) close(int)
  -> INLINE: (285,3) initVectorArray(Vector *, int)
    -> EXTERN: (182,31) malloc(size_t)
    -> EXTERN: (185,5) perror(const char *)
    -> EXTERN: (186,5) exit(int)
  -> INLINE: (286,3) storeVectorToArray(Vector *)
    -> INLINE: (235,9) doubleArraySize(Vector *)
      -> EXTERN: (199,31) malloc(size_t)
      -> EXTERN: (202,5) perror(const char *)
      -> EXTERN: (203,5) exit(int)
      -> EXTERN: (207,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
      -> EXTERN: (213,3) free(void *)
    -> INLINE (MANUAL): (239,36) atof(const char *)
      -> EXTERN: /usr/include/stdlib.h:(281,10) strtod(const char *__restrict__, char **__restrict__)
    -> EXTERN: (245,7) memset(void *, int, size_t)
  -> INLINE: (287,3) unmapFile(Vector *)
    -> EXTERN: (113,7) munmap(void *, size_t)
    -> EXTERN: (114,4) perror(const char *)
    -> EXTERN: (115,4) exit(int)
  -> INLINE: (288,3) computeHistogram(Vector *__restrict__, int, int)
    -> EXTERN: (39,15) malloc(size_t)
    -> EXTERN: (42,5) memset(void *, int, size_t)
  -> INLINE: (291,3) errorCheckVectors(Vector *, Vector *)
    -> EXTERN: (259,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (260,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (261,5) exit(int)
  -> INLINE: (296,3) initVectorArray(Vector *, int)
    -> EXTERN: (182,31) malloc(size_t)
    -> EXTERN: (185,5) perror(const char *)
    -> EXTERN: (186,5) exit(int)
  -> EXTERN: (297,3) vsAdd(const int, const float *, const float *, float *)
  -> INLINE: (298,3) computeHistogram(Vector *__restrict__, int, int)
    -> EXTERN: (39,15) malloc(size_t)
    -> EXTERN: (42,5) memset(void *, int, size_t)
  -> INLINE: (299,3) writeOutput(Vector *)
    -> EXTERN: (127,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (129,5) perror(const char *)
    -> EXTERN: (130,5) exit(int)
    -> EXTERN: (135,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> INLINE: (302,3) writeHistOutput(Vector *, char *)
    -> EXTERN: (158,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (160,5) perror(const char *)
    -> EXTERN: (161,5) exit(int)
    -> EXTERN: (166,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (168,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> INLINE: (303,3) writeHistOutput(Vector *, char *)
    -> EXTERN: (158,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (160,5) perror(const char *)
    -> EXTERN: (161,5) exit(int)
    -> EXTERN: (166,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (168,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> INLINE: (304,3) writeHistOutput(Vector *, char *)
    -> EXTERN: (158,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (160,5) perror(const char *)
    -> EXTERN: (161,5) exit(int)
    -> EXTERN: (166,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (168,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (307,3) free(void *)
  -> EXTERN: (308,3) free(void *)
  -> EXTERN: (309,3) free(void *)
  -> EXTERN: (312,3) free(void *)
  -> EXTERN: (313,3) free(void *)
  -> EXTERN: (314,3) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(228,3) inlined into vectorsum.c(277,3)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at vectorsum.c(44,5) inlined into vectorsum.c(279,3)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between hist line 49 and hist line 54
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at vectorsum.c(44,5) inlined into vectorsum.c(279,3)
<Remainder>
LOOP END

LOOP BEGIN at vectorsum.c(228,3) inlined into vectorsum.c(286,3)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at vectorsum.c(44,5) inlined into vectorsum.c(288,3)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between hist line 49 and hist line 54
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at vectorsum.c(44,5) inlined into vectorsum.c(288,3)
<Remainder>
LOOP END

LOOP BEGIN at vectorsum.c(44,5) inlined into vectorsum.c(298,3)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between  line 49 and  line 54
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at vectorsum.c(44,5) inlined into vectorsum.c(298,3)
<Remainder>
LOOP END

LOOP BEGIN at vectorsum.c(134,3) inlined into vectorsum.c(299,3)
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(135,5) ]
LOOP END

LOOP BEGIN at vectorsum.c(165,3) inlined into vectorsum.c(302,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 167 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 166 and call:fprintf(FILE *__restrict__, line 168
LOOP END

LOOP BEGIN at vectorsum.c(165,3) inlined into vectorsum.c(302,3)
<Predicate Optimized v2>
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(166,5) ]
LOOP END

LOOP BEGIN at vectorsum.c(165,3) inlined into vectorsum.c(303,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 167 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 166 and call:fprintf(FILE *__restrict__, line 168
LOOP END

LOOP BEGIN at vectorsum.c(165,3) inlined into vectorsum.c(303,3)
<Predicate Optimized v2>
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(166,5) ]
LOOP END

LOOP BEGIN at vectorsum.c(165,3) inlined into vectorsum.c(304,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 167 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 166 and call:fprintf(FILE *__restrict__, line 168
LOOP END

LOOP BEGIN at vectorsum.c(165,3) inlined into vectorsum.c(304,3)
<Predicate Optimized v2>
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(166,5) ]
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(42,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
vectorsum.c(42,5):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0); dynamic alignment is 16
vectorsum.c(42,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
vectorsum.c(42,5):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0); dynamic alignment is 16
vectorsum.c(42,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
vectorsum.c(42,5):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0); dynamic alignment is 16
vectorsum.c(245,7):remark #34026: call to memset implemented as a call to optimized library version
vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34026: call to memcpy implemented as a call to optimized library version
vectorsum.c(245,7):remark #34026: call to memset implemented as a call to optimized library version
vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34026: call to memcpy implemented as a call to optimized library version
===========================================================================

Begin optimization report for: computeHistogram(Vector *__restrict__, int, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (computeHistogram(Vector *__restrict__, int, int)) [4] vectorsum.c(31,1)
  -> EXTERN: (39,15) malloc(size_t)
  -> EXTERN: (42,5) memset(void *, int, size_t)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(44,5)
   remark #15523: loop was not vectorized: loop control variable vectorIndex was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(42,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
vectorsum.c(42,5):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0); dynamic alignment is 16
===========================================================================

Begin optimization report for: addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)) [5] vectorsum.c(64,1)


    Report from: Offload optimizations [offload]

OFFLOAD:addVectors(67,5):  Offload to target MIC 1
 Evaluate length/align/alloc_if/free_if/alloc/into expressions
   Modifier expression assigned to __offload_length.11
   Modifier expression assigned to __offload_length.12
   Modifier expression assigned to __offload_length.13
 Data sent from host to target
       v1, pointer to data with element count specified in pragma
       v2, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes
 Data received by host from target
       out, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes


    Report from: Code generation optimizations [cg]

vectorsum.c(67,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
vectorsum.c(67,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
===========================================================================

Begin optimization report for: mapFileToMemory(char *__restrict__, Vector *__restrict__)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (mapFileToMemory(char *__restrict__, Vector *__restrict__)) [6] vectorsum.c(80,64)
  -> INLINE (MANUAL): (85,3) stat(const char *, struct stat *)
    -> EXTERN: /usr/include/sys/stat.h:(457,10) __xstat(int, const char *, struct stat *)
  -> EXTERN: (89,8) open(const char *, int, ...)
  -> EXTERN: (91,5) perror(const char *)
  -> EXTERN: (92,5) close(int)
  -> EXTERN: (93,5) exit(int)
  -> EXTERN: (96,17) mmap(void *, size_t, int, int, int, __off_t)
  -> EXTERN: (98,5) perror(const char *)
  -> EXTERN: (99,5) close(int)
  -> EXTERN: (100,5) exit(int)
  -> EXTERN: (105,3) close(int)

===========================================================================

Begin optimization report for: unmapFile(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (unmapFile(Vector *)) [7] vectorsum.c(112,27)
  -> EXTERN: (113,7) munmap(void *, size_t)
  -> EXTERN: (114,4) perror(const char *)
  -> EXTERN: (115,4) exit(int)

===========================================================================

Begin optimization report for: writeOutput(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (writeOutput(Vector *)) [8] vectorsum.c(125,30)
  -> EXTERN: (127,9) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (129,5) perror(const char *)
  -> EXTERN: (130,5) exit(int)
  -> EXTERN: (135,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(134,3)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END
===========================================================================

Begin optimization report for: printVector(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (printVector(Vector *)) [9] vectorsum.c(145,31)
  -> EXTERN: (148,5) printf(const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(147,3)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END
===========================================================================

Begin optimization report for: writeHistOutput(Vector *, char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (writeHistOutput(Vector *, char *)) [10] vectorsum.c(156,50)
  -> EXTERN: (158,9) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (160,5) perror(const char *)
  -> EXTERN: (161,5) exit(int)
  -> EXTERN: (166,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (168,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(165,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 167 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 166 and call:fprintf(FILE *__restrict__, line 168
LOOP END

LOOP BEGIN at vectorsum.c(165,3)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between call:fprintf(FILE *__restrict__, line 166 and vec line 166
LOOP END
===========================================================================

Begin optimization report for: doubleArraySize(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (doubleArraySize(Vector *)) [11] vectorsum.c(197,35)
  -> EXTERN: (199,31) malloc(size_t)
  -> EXTERN: (202,5) perror(const char *)
  -> EXTERN: (203,5) exit(int)
  -> EXTERN: (207,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
  -> EXTERN: (213,3) free(void *)


    Report from: Code generation optimizations [cg]

vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34026: call to memcpy implemented as a call to optimized library version
===========================================================================

Begin optimization report for: storeVectorToArray(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (storeVectorToArray(Vector *)) [12] vectorsum.c(224,37)
  -> INLINE: (235,9) doubleArraySize(Vector *)
    -> EXTERN: (199,31) malloc(size_t)
    -> EXTERN: (202,5) perror(const char *)
    -> EXTERN: (203,5) exit(int)
    -> EXTERN: (207,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
    -> EXTERN: (213,3) free(void *)
  -> INLINE (MANUAL): (239,36) atof(const char *)
    -> EXTERN: /usr/include/stdlib.h:(281,10) strtod(const char *__restrict__, char **__restrict__)
  -> EXTERN: (245,7) memset(void *, int, size_t)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(228,3)
   remark #15523: loop was not vectorized: loop control variable mmapIdx was found, but loop iteration count cannot be computed before executing the loop
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(245,7):remark #34026: call to memset implemented as a call to optimized library version
vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(207,23):remark #34026: call to memcpy implemented as a call to optimized library version
===========================================================================

Begin optimization report for: errorCheckVectors(Vector *, Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (errorCheckVectors(Vector *, Vector *)) [13] vectorsum.c(257,51)
  -> EXTERN: (259,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (260,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (261,5) exit(int)

===========================================================================

Begin optimization report for: initVectorArray(Vector *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (initVectorArray(Vector *, int)) [14] vectorsum.c(179,49)
  -> EXTERN: (182,31) malloc(size_t)
  -> EXTERN: (185,5) perror(const char *)
  -> EXTERN: (186,5) exit(int)

===========================================================================
Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.


    Report from: Interprocedural optimizations [ipo]

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000


*MIC* Begin optimization report for: main(int, char **)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (main(int, char **)) [1] vectorsum.c(265,35)
  -> EXTERN: (268,5) fprintf
  -> EXTERN: (269,5) exit
  -> EXTERN: (275,3) mapFileToMemory
  -> EXTERN: (276,3) initVectorArray
  -> EXTERN: (277,3) storeVectorToArray
  -> EXTERN: (278,3) unmapFile
  -> EXTERN: (279,3) computeHistogram
  -> EXTERN: (284,3) mapFileToMemory
  -> EXTERN: (285,3) initVectorArray
  -> EXTERN: (286,3) storeVectorToArray
  -> EXTERN: (287,3) unmapFile
  -> EXTERN: (288,3) computeHistogram
  -> EXTERN: (291,3) errorCheckVectors
  -> EXTERN: (296,3) initVectorArray
  -> EXTERN: (297,3) vsAdd
  -> EXTERN: (298,3) computeHistogram
  -> EXTERN: (299,3) writeOutput
  -> EXTERN: (302,3) writeHistOutput
  -> EXTERN: (303,3) writeHistOutput
  -> EXTERN: (304,3) writeHistOutput
  -> EXTERN: (307,3) free
  -> EXTERN: (308,3) free
  -> EXTERN: (309,3) free
  -> EXTERN: (312,3) free
  -> EXTERN: (313,3) free
  -> EXTERN: (314,3) free

===========================================================================

*MIC* Begin optimization report for: addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)) [2] vectorsum.c(64,1)


    Report from: Offload optimizations [offload]

OFFLOAD:addVectors(67,5):  Outlined offload region
 Data received by target from host
       v1, pointer to data with element count specified in pragma
       v2, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes
 Data sent from target to host
       out, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(70,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between out line 72 and out line 72
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25018: Total number of lines prefetched=6
   remark #25019: Number of spatial prefetches=2, dist=64
   remark #25021: Number of initial-value prefetches=3
   remark #25035: Number of pointer data prefetches=4, dist=64
   remark #25139: Using second-level distance 6 for prefetching spatial memory reference   [ vectorsum.c(72,9) ]
   remark #25141: Using second-level distance 6 for prefetching pointer data reference   [ vectorsum.c(72,33) ]
   remark #25141: Using second-level distance 6 for prefetching pointer data reference   [ vectorsum.c(72,56) ]
LOOP END

LOOP BEGIN at vectorsum.c(70,5)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(67,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
vectorsum.c(67,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
===========================================================================
