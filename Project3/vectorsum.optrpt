Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.


    Report from: Interprocedural optimizations [ipo]

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000


Begin optimization report for: main(int, char **)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (main(int, char **)) [1] vectorsum.c(276,35)
  -> EXTERN: (279,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (280,5) exit(int)
  -> INLINE: (286,3) mapFileToMemory(char *__restrict__, Vector *__restrict__)
    -> INLINE (MANUAL): (96,3) stat(const char *, struct stat *)
      -> EXTERN: /usr/include/sys/stat.h:(457,10) __xstat(int, const char *, struct stat *)
    -> EXTERN: (100,8) open(const char *, int, ...)
    -> EXTERN: (102,5) perror(const char *)
    -> EXTERN: (103,5) close(int)
    -> EXTERN: (104,5) exit(int)
    -> EXTERN: (107,17) mmap(void *, size_t, int, int, int, __off_t)
    -> EXTERN: (109,5) perror(const char *)
    -> EXTERN: (110,5) close(int)
    -> EXTERN: (111,5) exit(int)
    -> EXTERN: (116,3) close(int)
  -> INLINE: (287,3) initVectorArray(Vector *, int)
    -> EXTERN: (193,31) malloc(size_t)
    -> EXTERN: (196,5) perror(const char *)
    -> EXTERN: (197,5) exit(int)
  -> INLINE: (288,3) storeVectorToArray(Vector *)
    -> INLINE: (246,9) doubleArraySize(Vector *)
      -> EXTERN: (210,31) malloc(size_t)
      -> EXTERN: (213,5) perror(const char *)
      -> EXTERN: (214,5) exit(int)
      -> EXTERN: (218,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
      -> EXTERN: (224,3) free(void *)
    -> INLINE (MANUAL): (250,36) atof(const char *)
      -> EXTERN: /usr/include/stdlib.h:(281,10) strtod(const char *__restrict__, char **__restrict__)
    -> EXTERN: (256,7) memset(void *, int, size_t)
  -> INLINE: (289,3) unmapFile(Vector *)
    -> EXTERN: (124,7) munmap(void *, size_t)
    -> EXTERN: (125,4) perror(const char *)
    -> EXTERN: (126,4) exit(int)
  -> (290,3) computeHistogram(Vector *__restrict__, int, int)
  -> INLINE: (295,3) mapFileToMemory(char *__restrict__, Vector *__restrict__)
    -> INLINE (MANUAL): (96,3) stat(const char *, struct stat *)
      -> EXTERN: /usr/include/sys/stat.h:(457,10) __xstat(int, const char *, struct stat *)
    -> EXTERN: (100,8) open(const char *, int, ...)
    -> EXTERN: (102,5) perror(const char *)
    -> EXTERN: (103,5) close(int)
    -> EXTERN: (104,5) exit(int)
    -> EXTERN: (107,17) mmap(void *, size_t, int, int, int, __off_t)
    -> EXTERN: (109,5) perror(const char *)
    -> EXTERN: (110,5) close(int)
    -> EXTERN: (111,5) exit(int)
    -> EXTERN: (116,3) close(int)
  -> INLINE: (296,3) initVectorArray(Vector *, int)
    -> EXTERN: (193,31) malloc(size_t)
    -> EXTERN: (196,5) perror(const char *)
    -> EXTERN: (197,5) exit(int)
  -> INLINE: (297,3) storeVectorToArray(Vector *)
    -> INLINE: (246,9) doubleArraySize(Vector *)
      -> EXTERN: (210,31) malloc(size_t)
      -> EXTERN: (213,5) perror(const char *)
      -> EXTERN: (214,5) exit(int)
      -> EXTERN: (218,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
      -> EXTERN: (224,3) free(void *)
    -> INLINE (MANUAL): (250,36) atof(const char *)
      -> EXTERN: /usr/include/stdlib.h:(281,10) strtod(const char *__restrict__, char **__restrict__)
    -> EXTERN: (256,7) memset(void *, int, size_t)
  -> INLINE: (298,3) unmapFile(Vector *)
    -> EXTERN: (124,7) munmap(void *, size_t)
    -> EXTERN: (125,4) perror(const char *)
    -> EXTERN: (126,4) exit(int)
  -> (299,3) computeHistogram(Vector *__restrict__, int, int)
  -> INLINE: (302,3) errorCheckVectors(Vector *, Vector *)
    -> EXTERN: (270,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (271,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (272,5) exit(int)
  -> INLINE: (307,3) initVectorArray(Vector *, int)
    -> EXTERN: (193,31) malloc(size_t)
    -> EXTERN: (196,5) perror(const char *)
    -> EXTERN: (197,5) exit(int)
  -> EXTERN: (309,3) vsAdd(const int, const float *, const float *, float *)
  -> (310,3) computeHistogram(Vector *__restrict__, int, int)
  -> INLINE: (311,3) writeOutput(Vector *)
    -> EXTERN: (138,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (140,5) perror(const char *)
    -> EXTERN: (141,5) exit(int)
    -> EXTERN: (146,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> INLINE: (314,3) writeHistOutput(Vector *, char *)
    -> EXTERN: (169,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (171,5) perror(const char *)
    -> EXTERN: (172,5) exit(int)
    -> EXTERN: (177,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (179,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> INLINE: (315,3) writeHistOutput(Vector *, char *)
    -> EXTERN: (169,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (171,5) perror(const char *)
    -> EXTERN: (172,5) exit(int)
    -> EXTERN: (177,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (179,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> INLINE: (316,3) writeHistOutput(Vector *, char *)
    -> EXTERN: (169,9) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: (171,5) perror(const char *)
    -> EXTERN: (172,5) exit(int)
    -> EXTERN: (177,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
    -> EXTERN: (179,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (319,3) free(void *)
  -> EXTERN: (320,3) free(void *)
  -> EXTERN: (321,3) free(void *)
  -> EXTERN: (324,3) free(void *)
  -> EXTERN: (325,3) free(void *)
  -> EXTERN: (326,3) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(239,3) inlined into vectorsum.c(288,3)
   remark #15523: loop was not vectorized: loop control variable mmapIdx was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at vectorsum.c(239,3) inlined into vectorsum.c(297,3)
   remark #15523: loop was not vectorized: loop control variable mmapIdx was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at vectorsum.c(145,3) inlined into vectorsum.c(311,3)
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(146,5) ]
LOOP END

LOOP BEGIN at vectorsum.c(176,3) inlined into vectorsum.c(314,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 178 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 177 and call:fprintf(FILE *__restrict__, line 179
LOOP END

LOOP BEGIN at vectorsum.c(176,3) inlined into vectorsum.c(314,3)
<Predicate Optimized v2>
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(177,5) ]
LOOP END

LOOP BEGIN at vectorsum.c(176,3) inlined into vectorsum.c(315,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 178 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 177 and call:fprintf(FILE *__restrict__, line 179
LOOP END

LOOP BEGIN at vectorsum.c(176,3) inlined into vectorsum.c(315,3)
<Predicate Optimized v2>
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(177,5) ]
LOOP END

LOOP BEGIN at vectorsum.c(176,3) inlined into vectorsum.c(316,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 178 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 177 and call:fprintf(FILE *__restrict__, line 179
LOOP END

LOOP BEGIN at vectorsum.c(176,3) inlined into vectorsum.c(316,3)
<Predicate Optimized v2>
   remark #15527: loop was not vectorized: function call to fprintf(FILE *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ vectorsum.c(177,5) ]
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(256,7):remark #34026: call to memset implemented as a call to optimized library version
vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34026: call to memcpy implemented as a call to optimized library version
vectorsum.c(256,7):remark #34026: call to memset implemented as a call to optimized library version
vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34026: call to memcpy implemented as a call to optimized library version
===========================================================================

Begin optimization report for: computeHistogram(Vector *__restrict__, int, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (computeHistogram(Vector *__restrict__, int, int)) [2] vectorsum.c(32,1)
  -> EXTERN: (40,15) malloc(size_t)
  -> EXTERN: (43,5) memset(void *, int, size_t)


    Report from: Offload optimizations [offload]

OFFLOAD:computeHistogram(51,7):  Offload to target MIC 1
 Evaluate length/align/alloc_if/free_if/alloc/into expressions
   Modifier expression assigned to __offload_length.11
   Modifier expression assigned to __offload_length.12
 Data sent from host to target
       v1, pointer to data with element count specified in pragma
       v2, pointer to data with element count specified in pragma
       length, scalar size 4 bytes
       vectorIndex, scalar size 4 bytes
       max, scalar size 4 bytes
       binIndex, scalar size 4 bytes
       min, scalar size 4 bytes
       binWidth, scalar size 4 bytes
 Data received by host from target
       v2, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes
       max, scalar size 4 bytes
       binIndex, scalar size 4 bytes
       min, scalar size 4 bytes
       binWidth, scalar size 4 bytes


    Report from: Code generation optimizations [cg]

vectorsum.c(43,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
vectorsum.c(43,5):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0); dynamic alignment is 16
vectorsum.c(51,7):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
vectorsum.c(51,7):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
===========================================================================

Begin optimization report for: addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)) [5] vectorsum.c(75,1)


    Report from: Offload optimizations [offload]

OFFLOAD:addVectors(78,5):  Offload to target MIC 1
 Evaluate length/align/alloc_if/free_if/alloc/into expressions
   Modifier expression assigned to __offload_length.11
   Modifier expression assigned to __offload_length.12
   Modifier expression assigned to __offload_length.13
 Data sent from host to target
       v1, pointer to data with element count specified in pragma
       v2, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes
 Data received by host from target
       out, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes


    Report from: Code generation optimizations [cg]

vectorsum.c(78,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
vectorsum.c(78,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
===========================================================================

Begin optimization report for: mapFileToMemory(char *__restrict__, Vector *__restrict__)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (mapFileToMemory(char *__restrict__, Vector *__restrict__)) [6] vectorsum.c(91,64)
  -> INLINE (MANUAL): (96,3) stat(const char *, struct stat *)
    -> EXTERN: /usr/include/sys/stat.h:(457,10) __xstat(int, const char *, struct stat *)
  -> EXTERN: (100,8) open(const char *, int, ...)
  -> EXTERN: (102,5) perror(const char *)
  -> EXTERN: (103,5) close(int)
  -> EXTERN: (104,5) exit(int)
  -> EXTERN: (107,17) mmap(void *, size_t, int, int, int, __off_t)
  -> EXTERN: (109,5) perror(const char *)
  -> EXTERN: (110,5) close(int)
  -> EXTERN: (111,5) exit(int)
  -> EXTERN: (116,3) close(int)

===========================================================================

Begin optimization report for: unmapFile(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (unmapFile(Vector *)) [7] vectorsum.c(123,27)
  -> EXTERN: (124,7) munmap(void *, size_t)
  -> EXTERN: (125,4) perror(const char *)
  -> EXTERN: (126,4) exit(int)

===========================================================================

Begin optimization report for: writeOutput(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (writeOutput(Vector *)) [8] vectorsum.c(136,30)
  -> EXTERN: (138,9) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (140,5) perror(const char *)
  -> EXTERN: (141,5) exit(int)
  -> EXTERN: (146,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(145,3)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END
===========================================================================

Begin optimization report for: printVector(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (printVector(Vector *)) [9] vectorsum.c(156,31)
  -> EXTERN: (159,5) printf(const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(158,3)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END
===========================================================================

Begin optimization report for: writeHistOutput(Vector *, char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (writeHistOutput(Vector *, char *)) [10] vectorsum.c(167,50)
  -> EXTERN: (169,9) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (171,5) perror(const char *)
  -> EXTERN: (172,5) exit(int)
  -> EXTERN: (177,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (179,7) fprintf(FILE *__restrict__, const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(176,3)
<Predicate Optimized v1>
   remark #25423: Condition at line 178 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between call:fprintf(FILE *__restrict__, line 177 and call:fprintf(FILE *__restrict__, line 179
LOOP END

LOOP BEGIN at vectorsum.c(176,3)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between call:fprintf(FILE *__restrict__, line 177 and vec line 177
LOOP END
===========================================================================

Begin optimization report for: doubleArraySize(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (doubleArraySize(Vector *)) [11] vectorsum.c(208,35)
  -> EXTERN: (210,31) malloc(size_t)
  -> EXTERN: (213,5) perror(const char *)
  -> EXTERN: (214,5) exit(int)
  -> EXTERN: (218,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
  -> EXTERN: (224,3) free(void *)


    Report from: Code generation optimizations [cg]

vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34026: call to memcpy implemented as a call to optimized library version
===========================================================================

Begin optimization report for: storeVectorToArray(Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (storeVectorToArray(Vector *)) [12] vectorsum.c(235,37)
  -> INLINE: (246,9) doubleArraySize(Vector *)
    -> EXTERN: (210,31) malloc(size_t)
    -> EXTERN: (213,5) perror(const char *)
    -> EXTERN: (214,5) exit(int)
    -> EXTERN: (218,23) memcpy(void *__restrict__, const void *__restrict__, size_t)
    -> EXTERN: (224,3) free(void *)
  -> INLINE (MANUAL): (250,36) atof(const char *)
    -> EXTERN: /usr/include/stdlib.h:(281,10) strtod(const char *__restrict__, char **__restrict__)
  -> EXTERN: (256,7) memset(void *, int, size_t)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(239,3)
   remark #15523: loop was not vectorized: loop control variable mmapIdx was found, but loop iteration count cannot be computed before executing the loop
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(256,7):remark #34026: call to memset implemented as a call to optimized library version
vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
vectorsum.c(218,23):remark #34026: call to memcpy implemented as a call to optimized library version
===========================================================================

Begin optimization report for: errorCheckVectors(Vector *, Vector *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (errorCheckVectors(Vector *, Vector *)) [13] vectorsum.c(268,51)
  -> EXTERN: (270,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (271,5) fprintf(FILE *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (272,5) exit(int)

===========================================================================

Begin optimization report for: initVectorArray(Vector *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (initVectorArray(Vector *, int)) [14] vectorsum.c(190,49)
  -> EXTERN: (193,31) malloc(size_t)
  -> EXTERN: (196,5) perror(const char *)
  -> EXTERN: (197,5) exit(int)

===========================================================================
Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.


    Report from: Interprocedural optimizations [ipo]

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000


*MIC* Begin optimization report for: main(int, char **)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (main(int, char **)) [1] vectorsum.c(276,35)
  -> EXTERN: (279,5) fprintf
  -> EXTERN: (280,5) exit
  -> EXTERN: (286,3) mapFileToMemory
  -> EXTERN: (287,3) initVectorArray
  -> EXTERN: (288,3) storeVectorToArray
  -> EXTERN: (289,3) unmapFile
  -> (290,3) computeHistogram(Vector *__restrict__, int, int)
  -> EXTERN: (295,3) mapFileToMemory
  -> EXTERN: (296,3) initVectorArray
  -> EXTERN: (297,3) storeVectorToArray
  -> EXTERN: (298,3) unmapFile
  -> (299,3) computeHistogram(Vector *__restrict__, int, int)
  -> EXTERN: (302,3) errorCheckVectors
  -> EXTERN: (307,3) initVectorArray
  -> EXTERN: (309,3) vsAdd
  -> (310,3) computeHistogram(Vector *__restrict__, int, int)
  -> EXTERN: (311,3) writeOutput
  -> EXTERN: (314,3) writeHistOutput
  -> EXTERN: (315,3) writeHistOutput
  -> EXTERN: (316,3) writeHistOutput
  -> EXTERN: (319,3) free
  -> EXTERN: (320,3) free
  -> EXTERN: (321,3) free
  -> EXTERN: (324,3) free
  -> EXTERN: (325,3) free
  -> EXTERN: (326,3) free

===========================================================================

*MIC* Begin optimization report for: computeHistogram(Vector *__restrict__, int, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (computeHistogram(Vector *__restrict__, int, int)) [2] vectorsum.c(32,1)
  -> EXTERN: (40,15) malloc
  -> EXTERN: (43,5) memset


    Report from: Offload optimizations [offload]

OFFLOAD:computeHistogram(51,7):  Outlined offload region
 Data received by target from host
       v1, pointer to data with element count specified in pragma
       v2, pointer to data with element count specified in pragma
       length, scalar size 4 bytes
       vectorIndex, scalar size 4 bytes
       max, scalar size 4 bytes
       binIndex, scalar size 4 bytes
       min, scalar size 4 bytes
       binWidth, scalar size 4 bytes
 Data sent from target to host
       v2, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes
       max, scalar size 4 bytes
       binIndex, scalar size 4 bytes
       min, scalar size 4 bytes
       binWidth, scalar size 4 bytes


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(54,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between v2 line 59 and v2 line 64
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25018: Total number of lines prefetched=2
   remark #25021: Number of initial-value prefetches=1
   remark #25035: Number of pointer data prefetches=2, dist=64
   remark #25141: Using second-level distance 4 for prefetching pointer data reference   [ vectorsum.c(57,14) ]
LOOP END

LOOP BEGIN at vectorsum.c(54,7)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(51,7):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
vectorsum.c(51,7):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
===========================================================================

*MIC* Begin optimization report for: addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (addVectors(Vector *__restrict__, Vector *__restrict__, Vector *__restrict__)) [3] vectorsum.c(75,1)


    Report from: Offload optimizations [offload]

OFFLOAD:addVectors(78,5):  Outlined offload region
 Data received by target from host
       v1, pointer to data with element count specified in pragma
       v2, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes
 Data sent from target to host
       out, pointer to data with element count specified in pragma
       vectorIndex, scalar size 4 bytes


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at vectorsum.c(81,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between out line 83 and out line 83
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25018: Total number of lines prefetched=6
   remark #25019: Number of spatial prefetches=2, dist=64
   remark #25021: Number of initial-value prefetches=3
   remark #25035: Number of pointer data prefetches=4, dist=64
   remark #25139: Using second-level distance 6 for prefetching spatial memory reference   [ vectorsum.c(83,9) ]
   remark #25141: Using second-level distance 6 for prefetching pointer data reference   [ vectorsum.c(83,33) ]
   remark #25141: Using second-level distance 6 for prefetching pointer data reference   [ vectorsum.c(83,56) ]
LOOP END

LOOP BEGIN at vectorsum.c(81,5)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

    Report from: Code generation optimizations [cg]

vectorsum.c(78,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
vectorsum.c(78,5):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (64, 0), and destination (alignment, offset): (64, 0)
===========================================================================
